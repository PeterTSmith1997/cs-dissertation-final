\section{System Architecture}

This section will look at the design of the software from an architectural point of view, the design of the user interface will be discussed in a later section (\ref{ui}). 

The code is divided into 3 sub-systems; these sub-systems were then made up of relevant files. The first sub-system is the data model; this system is where all the back-end calculations are performed and then passed to one of the other sub-systems. The other two sub-systems are the main user interface and the admin user interface. By designing these three components as separate sub-sections, it enforces a highly cohesive design with low coupling. The systems could be written independently of one another, supporting the agility of the design as a whole. The data model was written first as a basic text output, this aided in design; due to the fact that when it came to the UI, the data that needed to be displayed was already available and calculated. It also meant that pinpointing a formatting error was easier to locate, for example, if the error was in the raw data or the UI. 

After a user selects a file to be read into the software, each line of the data is stored as an object and then each object is placed into an array-list ready for further processing as needed. An array-list is a Java data structure that allows the storage of items. In this particular project, the array-list is used to store a collection of objects, namely the website hits. A hit is defined as one line of data within the log file. The data is stored in an 'object of type' data store'. The data store is then passed between UI's, this results in all UI's being able access the correct data, it also saves passing multiple arrays and maps. This makes it easier to pass the data around the software in a consistent way.

An array-list was chosen as the data structure due to its superior performance (\cite{JavaAL}). Due to the size of the website log-file, in terms of number of entries, the dynamic size of the array-list is more suitable for this project. An array is a fixed size, meaning the only logical way to use an array would be to set the size to a large number and hope no data would be larger (\cite{Array}). After the array-list has been populated it is then sorted into multiple hash-maps so that the data can be easily interrogated, for example: the number of times an IP shows in the data can be saved as a key value pair. 


%Much of the data used to... calculated UI displays is stored as a hash map; this makes it easier to do a lot of basic manipulation of the data. Other types of maps were considered for example a TreeMap however, due to the the fact that a HashMap is generally quicker and the application is not focusing on the order of the IP address, then a HashMap seemed like a better option however, because they all use the map interface, if at a late date a different map would be better, then this could be easily changed. https://www.geeksforgeeks.org/differences-treemap-hashmap-linkedhashmap-java/

Due to the software's heavy reliance on a database architecture when calculating values, it was considered good practice to use a database class to control access to the database. This means that the control of the database is abstracted away from the main code, therefore, it will improve the overall cohesiveness of the software. High cohesion gives the software a better facility for maintenance, while low cohesion results in monolithic classes that are  much more difficult to maintain, and generally reduces re-usability. Due to the complex nature of the design, by having high cohesion, it was easier to insert adaptations during the design implementation.
