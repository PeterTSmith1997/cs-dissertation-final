\section{Design decisions}

During this section the approach to the software requirements shall be discussed. The requirements are outlined in Chapter 5 and Appendix \ref{Moscow}. Relevant arguments shall be debated in order to comprise best practice for the design of the software, including the justifications for any vital decisions made. The formulation of the design shall in turn be built in order to prove or disprove the hypotheses that have been raised in this chapter. 

When considering a choice of language to use in the software, the following considerations had to be made, after elements of the justifications section were taken into account. The first point that was considered was the primary concern of the software being able to maintain confidentiality and how it may have an impact upon the results of the software. In essence, it is considered imperative to keep the data collected away from the eyes of potential attackers or hackers. For this reason PHP as a language was disregarded, as it would lead to the software being available online. This would make the data potentially available for malicious users to access online. 

It was decided to design the software utilizing an object orientated approach; this approach means that the software can be designed as a series of objects that interact with each other (\cite{OOP}). Using an object oriented approach allows for easier implementation of new data and function as opposed to a procedural approach; this will lead to a more agile methodology when developing the code. Object oriented programming also provides 'data hiding' which in turn, makes the approach as a whole more secure. This was considered a boon due to the fact that this would mean that the data within the program is neatly categorised and sectioned. It is considered beneficial to keep the UI coding separate from the functional code. It is also valid to mention that in object oriented programming, data is more important than function. In the software, data is the most important aspect of the framework and the functionality is secondary. Due to the complex nature of the data driven approach, data could be analysed easily and can be manipulated in many ways to produce logical outputs.

Another language that was considered to be a close contender for the language of choice was C. C would have been an appropriate choice if we were using it on a server due to the fact that C is the base language of servers, as they tend to run unix systems (\cite{ehost}). Due to the complex nature of the program there may have been some issues implementing C as a language. C is a procedural language, therefore, it requires the code to be longer. There are also some inherent issues when using objects to represent data. On the other hand, Java, is built in objects, therefore it is easier to represent complex data structures by using objects. For example, each line in the log file is represented as an object. 

Python was also assessed as a contender for writing the software. Due to the fact that Python is dynamically typed, this would make the task of debugging some errors longer. Java on the other hand is statically typed, it expects the variables to be declared before they can be assigned values; this prohibits running the code if errors are generated. It also means that you are unable to accidentally alter a data file into an incompatible form. The prevention of error and debugging ease of Java were the deciding factors in promoting Java above the other languages. It was concluded that Java was the most appropriate language for the development. 

The database runs as an SQL database, this was chosen above 'no SQL' for the following reasons: The first is that it enables the use of joins, this reduces the data that needs to be stored as some of the data would be replicated. For example, every IP has a type, without join this would need to be a text parameter, hence by using joins we can save the type in a different table and then make reference to them in the IP table. Another reason for utilising SQL is that it is highly compatible across a number of different devices; this would be beneficial to the overall development of the project through ease of access. A third and final reason that SQL was selected is that SQL works hand in hand with Java in terms of compatibility, and as discussed previously, Java was selected as the best candidate for a language choice. 

